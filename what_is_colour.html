<!DOCTYPE html>
<html>

<head>
    <title>What is Colour? - The Colours of Noise</title>
    <link rel="icon" href="Images/icon-06.png" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body style="background-color: grey;">

  <!-- Nav Bar -->
    <div class="topnav">
        <a href="index.html">What is Noise?</a>
        <a class="active" href="what_is_colour.html">What is Colour?</a>
        <a href="how_they_connect.html">The Connection</a>
        <a href="pick_your_colour.html">Pick Your Colour</a>
    </div>

    <!-- First Information on Colour Section, explaining how we see colour -->
    <div class="colourcontainer1">
        <div class="firstColourTextContainer">
        <h1 class="backgroundtext">Colour: How does it Work?</h1>
        <p class="whatiscolourtext">
            All light is part of a big family called electromagnetic radiation. 
            <p class="whatiscolourtext"> We can only see a small part of it called visible light. Our eyes have special cells that can pick up these visible light waves.

            <p class="whatiscolourtext"> When you shine light through a prism, all visible colours spread out because each colour has a different size of wave, much like in noise frequency. These colours make up what we can see in a rainbow. </p> 
        </p>
    </div>
</div>

<!-- place where back to top button will take the user after clicking  -->
<a id="backToTopButton"></a> 

<!-- Prism Instructions and Interaction Section -->
        <div class="prismSection">
  <div class="textContainer">
    <h1 class="tryItOut">Try it out!</h1>
    <p class="whatiscolourtext">See how light shines through a prism using this simulator.</p>
    <p class="whatiscolourtext">Move your mouse towards the triangle to activate the white light. Then, move your mouse up or down to see how the colours respond! </p>
  </div>
  <!-- calling the p5.js prism canvas -->
  <div id="prismContainer" class="prismContainer"></div>  
</div>


<!-- Back to top button inspired by Matthew Cane's back to top button (https://codepen.io/matthewcain/pen/ZepbeR) -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        var btn = $('#backToTopButton');

        $(window).scroll(function() {
            if ($(window).scrollTop() > 300) { // appears just after Prism intstructions and interaction section
                btn.addClass('show');
            } else {
                btn.removeClass('show');
            }
        });

        btn.on('click', function(e) {
            e.preventDefault();
            $('html, body').animate({scrollTop:0}, '300'); // on click, goes to top of page
        });
    });
</script>


<script> // Fade in/fade out controls for prism interaction and instructions section! This is used with IntersectionObserver 
  document.addEventListener("DOMContentLoaded", function () {
    const prismSection = document.querySelector(".prismSection");

    function revealPrismSection(entries, observer) {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          prismSection.classList.add("reveal");
        } else {
          prismSection.classList.remove("reveal");
        }
      });
    }

    const observer = new IntersectionObserver(revealPrismSection, {
      threshold: 0.5 // when 50% of the section is scrolled to, the section will appear 
    });

    observer.observe(prismSection);
  });
</script>

<!-- calling image background here -->
<div id="colourbackground"></div> 

<!-- Visible Light Spectrum Section -->
<div class='lightSpectrumSection'>
    <h1 class="vslText">The Visible Light Spectrum</h1>
    <p class="whatiscolourtext"> We can use a visible light spectrum chart to understand fully how each colour has a differently sized light waves.</p>
    <!-- showcasing the vls chart I created -->
    <img class="lsChartImage"src="Images/vlsChart.png"> 
    
    <!-- information on the section -->
    <p class="whatiscolourtext">
      Measured in nanometers(nm), each colour's wave is differently sized. 
    </p>
    <p class="whatiscolourtext">Violet is at one end of the visible light spectrum with the shortest waves at around 400nm long. Red is at the other end with the longest waves which is about 700nm long.</p>
    <p class="whatiscolourtext">  This can explain why it might be harder to see some colours over others.</p>
  </div>
  

  <!-- Fade in/fade out controls for Visible Light Spectrum Section! This is used with IntersectionObserver  -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const lightSpectrumSection = document.querySelector(".lightSpectrumSection");
  
      function revealLightSpectrumSection(entries, observer) {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            lightSpectrumSection.classList.add("reveal");
          } else {
            lightSpectrumSection.classList.remove("reveal");
          }
        });
      }
  
      const observer = new IntersectionObserver(revealLightSpectrumSection, {
        threshold: 0.5 // when 50% of the section is scrolled to, the section will appear 
      });
  
      observer.observe(lightSpectrumSection);
    });
  </script>

<!-- Frequency and Colour Wheel Section -->
    <section class="frequencyColourWheelSection">
      <!-- Information on frequency fitting within a colour wheel -->
        <h1 class="backgroundtext2">How does Frequency Fit In?</h1>
        <p class="aboveWhatIsColourText">On the colour wheel, colours such as violet are associated with shorter wavelengths, while others such as red are linked to longer wavelengths. </p>
          <p class="aboveWhatIsColourText2">Colours are arranged on the wheel from shortest (violet) to longest (red) as a spectrum of wavelengths, much like the visible light spectrum chart above.</p>
        
        <div class="colourcontainer2">
          <!-- calling the p5.js spinning colour wheel -->
          <div id="wheelContainer" class="wheelContainer"></div>
          <div class="frequencyTextContainer">
            <p class="whatiscolourtext2">
              <!-- more information on frequency and colour -->
              In this context, frequency tells us how often a colour will pass by in a second while the wheel is spinning.
            </p>
            <p class="whatiscolourtext2">
              Shorter wavelength colours like violet pass by your eyes more frequently because they're closer together on the wheel. This means they have a higher frequency.
            </p>
            <p class="whatiscolourtext2">
              Longer wavelength colours like red pass by less frequently because they're farther apart on the wheel, resulting in a lower frequency.
            </p>
          </div>
        </div>
      </section>
      
      <!-- Fade in/fade out controls for Frequency and Colour Wheel Section This is used with IntersectionObserver  -->
      <script>
        document.addEventListener("DOMContentLoaded", function () {
          const frequencyColourWheelSection = document.querySelector(".frequencyColourWheelSection");
      
          function revealFrequencyColourWheelSection(entries, observer) {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                frequencyColourWheelSection.classList.add("reveal");
              } else {
                frequencyColourWheelSection.classList.remove("reveal");
              }
            });
          }
      
          const observer = new IntersectionObserver(revealFrequencyColourWheelSection, {
            threshold: 0.5 // when 50% of the section is scrolled to, the section will appear
          });
      
          observer.observe(frequencyColourWheelSection);
        });
      </script>

<!-- Prism interaction using p5.js -->
<!-- Inspired by "The dark side of the moon" p5.js sketch by shibomb (https://editor.p5js.org/shibomb/sketches/aap3fybBt) **did not take any code-->
    <script>
        let lightBeamLength = 250; // Initial length of the light beam
        let lightIntersecting = false; // Flag to indicate if the light beam intersects with the triangle
        let spectrumLength = 50; // Initial length of the spectrum lines

        function setup() {
           let prism = createCanvas(600, 600); // sizing of canvas
           prism.parent('prismContainer'); // parent so it can go anywhere on the page
            frameRate(120); // speed of animation
        }

        function draw() {
            background(25); // defining functions 
            lightBeam();
            spectrum();
            innerPrism();
            prism();
        }

        function lightBeam() {
            let endX = mouseX;  // mouse x and mouse y controls for when it intersects
            let endY = mouseY;

            
            let intersection = getLightBeamTriangleIntersection(0, 350, endX, endY); // finding intersection point from triangle
            if (intersection) {
                endX = intersection.x;
                endY = intersection.y;
                lightIntersecting = true; // set to true if light intersects with triangle
            } else {
                lightIntersecting = false; // set to false if light does not intersect with triangle
            }

            // dotted line instead of solid
            stroke(255);
            strokeWeight(2); 
            let dottedSpacing = 8; // spacing 

            // p5.js lerps so it can calculate between one space and another
            for (let i = 0; i < lightBeamLength; i += dottedSpacing * 2) {  // setting up a loop so the white dots in the line have spacing between them
                let x1 = lerp(0, endX, i / lightBeamLength); // calculating starting and ending point of the x position of line
                let y1 = lerp(350, endY, i / lightBeamLength); // calculating starting and ending point of y position of line
                let x2 = lerp(0, endX, (i + dottedSpacing) / lightBeamLength);  // allowing the spacing between line
                let y2 = lerp(350, endY, (i + dottedSpacing) / lightBeamLength); // allowing spacing between line
                line(x1, y1, x2, y2); // creating the dotted line 
            }
        }

        function prism() {  // making the main triangle
            noFill(); // no colour inside
            strokeWeight(6);
            stroke(255); // white
            triangle(300, 200, 175, 400, 425, 400); // creating the triangle

            // adding depth with another triangle
            noFill();
            strokeWeight(7);
            stroke(255, 150); // greyish
            triangle(300, 203, 178, 397, 422, 397); // creating inner triange
        }

        function innerPrism() {
        }

        function spectrum() {
            let lightX = mouseX;  // mouse controls
            let lightY = mouseY;

            if (lightIntersecting) {
                let lightAngle = atan2(lightY - 350, lightX); // angle of beam (so it's not going face down)

                let x1 = 348, y1 = 270; // start of line
                let x2 = x1 + spectrumLength * cos(lightAngle); // end spectrum line
                let y2 = y1 + spectrumLength * sin(lightAngle); // end spectrum line

               // spectrum colors
                let colors = [
                    [255, 34, 0],
                    [255, 119, 0],
                    [255, 191, 0],
                    [255, 238, 0],
                    [221, 255, 0],
                    [80, 255, 0],
                    [0, 255, 0],
                    [0, 170, 255],
                    [0, 34, 255],
                    [136, 50, 255],
                    [230, 75, 175]
                ];

                // drawing the sprectrum coloured lines
                for (let n = 0; n < 11; n++) {
                    let [a, b, c] = colors[n];
                    stroke(a, b, c, 250); // visibility settings
                    strokeWeight(5); // visibility settings
                    line(x1, y1, x2, y2); 
                    x1 += 2.2;
                    y1 += 3;
                    spectrumLength += 1; // length of line, makes a little animation
                }
            }
        }

        function getLightBeamTriangleIntersection(x1, y1, x2, y2) {
           // intersection verts
            let v1 = createVector(300, 200);
            let v2 = createVector(175, 400);
            let v3 = createVector(425, 400);

          // checking intersection with the triangle
            let intersection1 = getLineIntersection(x1, y1, x2, y2, v1.x, v1.y, v2.x, v2.y);
            let intersection2 = getLineIntersection(x1, y1, x2, y2, v2.x, v2.y, v3.x, v3.y);
            let intersection3 = getLineIntersection(x1, y1, x2, y2, v3.x, v3.y, v1.x, v1.y);

            // checking to see where the nearest intersection is
            let nearestIntersection = null;
            if (intersection1 && (!nearestIntersection || dist(x1, y1, intersection1.x, intersection1.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection1;
            }
            if (intersection2 && (!nearestIntersection || dist(x1, y1, intersection2.x, intersection2.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection2;
            }
            if (intersection3 && (!nearestIntersection || dist(x1, y1, intersection3.x, intersection3.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection3;
            }

            return nearestIntersection;
        }

        function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            // direction of the lines, i did look this up
            let uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            let uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

            // if the intersection point is within both line segments, return the coordinates
            if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
                let intersectionX = x1 + (uA * (x2 - x1));
                let intersectionY = y1 + (uA * (y2 - y1));
                return createVector(intersectionX, intersectionY);
            } else {
                return null;
            }
        }
    </script>

<!-- Spinning colour wheel section -->
<!-- Followed a tutorial by The Coding Train on Youtube to make the second canvas happen. https://www.youtube.com/watch?v=Su792jEauZg -->
    <script>
        // COLOUR WHEEL 
        var sketch = function (c) {  // "C" was used for "Colour Wheel" in creating a new p5.js canvas
            // defining colours
            const red = "#FE2712";
            const redOrange = "#FC600A";
            const orange = "#FB9902";
            const yellowOrange = "#FCCC1A";
            const yellow = "#FEFE33";
            const yellowGreen = "#B2D732";
            const green = "#66B032";
            const blueGreen = "#347C98";
            const blue = "#0247FE";
            const bluePurple = "#4424D6";
            const purple = "#8601AF";
            const redPurple = "#C21460";

            const size = 400; // size of wheel (tbc)
            const colors = [red, redOrange, orange, yellowOrange, yellow, yellowGreen, green, blueGreen, blue, bluePurple, purple, redPurple]; // so i don't have to ref each individually

            let angle = 0; // starting off to spin it

            c.setup = function () {
                let wheel = c.createCanvas(600, 600);
                wheel.parent('wheelContainer');
            };

            c.draw = function () {
                c.translate(c.width / 2, c.height / 2); // center of page
                var segmentAngle = c.TWO_PI / colors.length; // 12 segments to the circle
                for (var i = 0; i < colors.length; i++) {

                    var currentColor = getColorAtAngle(angle + i * segmentAngle); //calculating current color from angle
                    c.fill(currentColor);
                    c.stroke(currentColor);
                    // Calculate arc coordinates
                    var startAngle = i * segmentAngle - c.HALF_PI;
                    var endAngle = (i + 1) * segmentAngle - c.HALF_PI;
                    c.arc(0, 0, size, size, startAngle, endAngle, c.PIE); // drawing the arc with start/end angles
                }

                angle += 0.04; //allows the wheel to spin
            };

            function getColorAtAngle(angle) {

                var index = c.floor(c.map(angle % c.TWO_PI, 0, c.TWO_PI, 0, colors.length)); // find the index of the color from angle

                var fraction = (angle % (c.TWO_PI / colors.length)) / (c.TWO_PI / colors.length); //  the section between the current color and the next color
                // Interpolate between the current color and the next color
                return c.lerpColor(c.color(colors[index]), c.color(colors[(index + 1) % colors.length]), fraction); // lerp between the current color and the next color
            }
        };

        var myp5 = new p5(sketch); // init sketch so it's visible
    </script>

</body>

</html>
