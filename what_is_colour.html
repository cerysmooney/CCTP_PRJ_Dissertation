<!DOCTYPE html>
<html>

<head>
    <title>What is Colour?</title>
    <link rel="icon" href="Images/icon-06.png" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body style="background-color: grey;">

    <div class="topnav">
        <a href="index.html">What is Noise?</a>
        <a class="active" href="what_is_colour.html">What is Colour?</a>
        <a href="how_they_connect.html">The Connection</a>
        <a href="pick_your_colour.html">Pick Your Colour</a>
        <!-- <a href="white_noise.html">White</a>
        <a href="pink_noise.html">Pink</a>
        <a href="blue_noise.html">Blue</a>
        <a href="brown_noise.html">Brown</a>
        <a href="violet_noise.html">Violet</a> -->
    </div>

    <!-- First Information on Colour Section -->
    <div class="colourcontainer1">
        <div class="firstColourTextContainer">
        <h1 class="backgroundtext">Colour: How does it Work?</h1>
        <p class="whatiscolourtext">
            <!-- WORK ON WORDING GOOD LORD -->
            All light is part of a big family called electromagnetic radiation. We can only see a small part of it called visible light. Our eyes have special cells that can pick up these visible light waves.

            <p class="whatiscolourtext"> When you shine light through a prism, all visible colours spread out because each colour has a different size of wave, much like in noise frequency. These colours make up a rainbow. </p> 
        </p>
    </div>
</div>

        <div class="prismSection">
  <div class="textContainer">
    <h1 class="tryItOut">Try it out!</h1>
    <p class="whatiscolourtext">See how light shines through a prism using this simulator.</p>
    <p class="whatiscolourtext">Move your mouse towards the triangle to activate the white light. Then, move your mouse up or down to see how the colours respond! </p>
  </div>
  <div id="prismContainer" class="prismContainer"></div>
</div>

<script>
document.addEventListener("DOMContentLoaded", function () {
  var prismSection = document.querySelector(".prismSection");

  function revealPrismSection() {
    var prismSectionPosition = prismSection.getBoundingClientRect().top;
    var screenPosition = window.innerHeight / 3;

    if (prismSectionPosition < screenPosition) {
      prismSection.classList.add("reveal");
    }else{
        prismSection.classList.remove("reveal");
    }
  }

  window.addEventListener("scroll", revealPrismSection);
  revealPrismSection(); // Call the function once on page load
});
</script>
<div id="colourbackground"></div>
<div class='lightSpectrumSection'>
    <h1 class="vslText">The Visible Light Spectrum</h1>
    <p class="whatiscolourtext"> We can use a visible light spectrum chart to understand fully how each colour has a differently sized light waves.</p>
    <img class="lsChartImage"src="Images/vlsChart.png">
    
    <p class="whatiscolourtext">
      Measured in nanometers(nm), each colour's wave is differently sized.  Violet is at one end of the visible light spectrum with the shortest waves at around 400nm long. Red is at the other end with the longest waves which is about 700nm long.
      This can explain why it might be harder to see some colours over others.
    </p>
  </div>
  
  <script>
  document.addEventListener("DOMContentLoaded", function () {
    var lightSpectrumSection = document.querySelector(".lightSpectrumSection");
  
    function revealLightSpectrumSection() {
      var lightSpectrumSectionPosition = lightSpectrumSection.getBoundingClientRect().top;
      var screenPosition = window.innerHeight / 2;
  
      if (lightSpectrumSectionPosition < screenPosition) {
        lightSpectrumSection.classList.add("reveal");
      }else{
        lightSpectrumSection.classList.remove("reveal");
      }
    }
  
    window.addEventListener("scroll", revealLightSpectrumSection);
    revealLightSpectrumSection(); // Call the function once on page load
  });
  </script>

    <section class="frequencyColourWheelSection">
        <h1 class="backgroundtext2">How does Frequency Fit In?</h1>
        <p class="aboveWhatIsColourText">On the color wheel, colors such as violet are associated with shorter wavelengths, while others such as red are linked to longer wavelengths. The colors are arranged on the wheel from shortest (violet) to longest (red) as a spectrum of wavelengths, much like the visible light spectrum chart above.</p>
        
        <div class="colourcontainer2">
          <div id="wheelContainer" class="wheelContainer"></div>
          <div class="frequencyTextContainer">
            <p class="whatiscolourtext2">
              In this context, frequency tells us how often a color will pass by in a second while the wheel is spinning.
            </p>
            <p class="whatiscolourtext2">
              Shorter wavelength colors like violet pass by your eyes more frequently because they're closer together on the wheel. This means they have a higher frequency.
            </p>
            <p class="whatiscolourtext2">
              Longer wavelength colors like red pass by less frequently because they're farther apart on the wheel, resulting in a lower frequency.
            </p>
          </div>
        </div>
      </section>
      
      <script>
      document.addEventListener("DOMContentLoaded", function () {
        var frequencyColourWheelSection = document.querySelector(".frequencyColourWheelSection");
      
        function revealFrequencyColourWheelSection() {
          var sectionPosition = frequencyColourWheelSection.getBoundingClientRect().top;
          var screenPosition = window.innerHeight / 2;
    
          if (sectionPosition < screenPosition) {
            frequencyColourWheelSection.classList.add("reveal");
          
        } else {
      frequencyColourWheelSection.classList.remove("reveal"); 
        }
    }

        window.addEventListener("scroll", revealFrequencyColourWheelSection);
        revealFrequencyColourWheelSection(); 
      });
      </script>



    <!-- <a href="#third">
        <div class="scroll-down-third"></div>
    </a> -->

    <!-- Third Information on Colour Screen -->
    <!-- <a id="third"></a>
    <div class="colourcontainer3">
        <h1 class="backgroundtext3">How does frequency fit in?
        </h1>
        <p class="whatiscolourtext3">
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eos unde cum veritatis.
        </p>
        <img class="placebearBrown" src="Images/Colour.1">
    </div> -->

    <div class="whatIsColourP5Container"></div>

    <script>
        let lightBeamLength = 250; // Initial length of the light beam
        let lightIntersecting = false; // Flag to indicate if the light beam intersects with the triangle
        let spectrumLength = 50; // Initial length of the spectrum lines

        function setup() {
           let prism = createCanvas(600, 600); 
           prism.parent('prismContainer');
            frameRate(120);
        }

        function draw() {
            background(25); // defining functions 
            lightBeam();
            spectrum();
            innerPrism();
            prism();
        }

        function lightBeam() {
            let endX = mouseX;  // mouse x and mouse y controls for when it intersects
            let endY = mouseY;

            
            let intersection = getLightBeamTriangleIntersection(0, 350, endX, endY); // finding intersection point from triangle
            if (intersection) {
                endX = intersection.x;
                endY = intersection.y;
                lightIntersecting = true; // set to true if light intersects with triangle
            } else {
                lightIntersecting = false; // set to false if light does not intersect with triangle
            }

            // dotted line instead of solid
            stroke(255);
            strokeWeight(2);
            let dottedSpacing = 8; // spacing 

            // p5.js lerps 
            for (let i = 0; i < lightBeamLength; i += dottedSpacing * 2) {
                let x1 = lerp(0, endX, i / lightBeamLength);
                let y1 = lerp(350, endY, i / lightBeamLength);
                let x2 = lerp(0, endX, (i + dottedSpacing) / lightBeamLength);
                let y2 = lerp(350, endY, (i + dottedSpacing) / lightBeamLength);
                line(x1, y1, x2, y2);
            }
        }

        function prism() {  // making the main triangle
            noFill();
            strokeWeight(6);
            stroke(255);
            triangle(300, 200, 175, 400, 425, 400);

            // adding depth with another triangle
            noFill();
            strokeWeight(7);
            stroke(255, 150); 
            triangle(300, 203, 178, 397, 422, 397);
        }


        // STILL FIGURING THIS SECTION OUT
        function innerPrism() {
            // let x1 = 255, y1 = 280, x2 = 345, y2 = 266;
            // let n = 0;
            // while (n < 11) {
            //     stroke(255, 20); // Adjusted stroke color for better visibility
            //     strokeWeight(0.5); // Adjusted stroke weight for better visibility
            //     line(x1, y1, x2, y2);
            //     x2 += 1.3;
            //     y2 += 3.45;
            //     n++;
            // }
        }

        function spectrum() {
            let lightX = mouseX;  // mouse controls
            let lightY = mouseY;

            if (lightIntersecting) {
                let lightAngle = atan2(lightY - 350, lightX); // angle of beam (so it's not going face down)

                let x1 = 348, y1 = 270; // start of line
                let x2 = x1 + spectrumLength * cos(lightAngle); // end spectrum line
                let y2 = y1 + spectrumLength * sin(lightAngle); // end spectrum line

               // spectrum colors
                let colors = [
                    [255, 34, 0],
                    [255, 119, 0],
                    [255, 191, 0],
                    [255, 238, 0],
                    [221, 255, 0],
                    [80, 255, 0],
                    [0, 255, 0],
                    [0, 170, 255],
                    [0, 34, 255],
                    [136, 50, 255],
                    [230, 75, 175]
                ];

                for (let n = 0; n < 11; n++) {
                    let [a, b, c] = colors[n];
                    stroke(a, b, c, 250); // visibility settings
                    strokeWeight(5); // visibility settings
                    line(x1, y1, x2, y2);
                    x1 += 2.2;
                    y1 += 3;
                    spectrumLength += 1; // length of line, makes a little animation
                }
            }
        }

        function getLightBeamTriangleIntersection(x1, y1, x2, y2) {
           // intersection verts
            let v1 = createVector(300, 200);
            let v2 = createVector(175, 400);
            let v3 = createVector(425, 400);

          // checking intersection with the triangle
            let intersection1 = getLineIntersection(x1, y1, x2, y2, v1.x, v1.y, v2.x, v2.y);
            let intersection2 = getLineIntersection(x1, y1, x2, y2, v2.x, v2.y, v3.x, v3.y);
            let intersection3 = getLineIntersection(x1, y1, x2, y2, v3.x, v3.y, v1.x, v1.y);

            // checking to see where the nearest intersection is
            let nearestIntersection = null;
            if (intersection1 && (!nearestIntersection || dist(x1, y1, intersection1.x, intersection1.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection1;
            }
            if (intersection2 && (!nearestIntersection || dist(x1, y1, intersection2.x, intersection2.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection2;
            }
            if (intersection3 && (!nearestIntersection || dist(x1, y1, intersection3.x, intersection3.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
                nearestIntersection = intersection3;
            }

            return nearestIntersection;
        }

        function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            // direction of the lines, i did look this up
            let uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            let uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

            // if the intersection point is within both line segments, return the coordinates
            if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
                let intersectionX = x1 + (uA * (x2 - x1));
                let intersectionY = y1 + (uA * (y2 - y1));
                return createVector(intersectionX, intersectionY);
            } else {
                return null;
            }
        }
    </script>

    <script>
        // COLOUR WHEEL 
        var sketch = function (c) {
            // defining colours
            const red = "#FE2712";
            const redOrange = "#FC600A";
            const orange = "#FB9902";
            const yellowOrange = "#FCCC1A";
            const yellow = "#FEFE33";
            const yellowGreen = "#B2D732";
            const green = "#66B032";
            const blueGreen = "#347C98";
            const blue = "#0247FE";
            const bluePurple = "#4424D6";
            const purple = "#8601AF";
            const redPurple = "#C21460";

            const size = 400; // size of wheel (tbc)
            const colors = [red, redOrange, orange, yellowOrange, yellow, yellowGreen, green, blueGreen, blue, bluePurple, purple, redPurple]; // so i don't have to ref each individually

            let angle = 0; // starting off to spin it

            c.setup = function () {
                let wheel = c.createCanvas(600, 600);
                wheel.parent('wheelContainer');
            };

            c.draw = function () {
                c.translate(c.width / 2, c.height / 2); // center of page
                var segmentAngle = c.TWO_PI / colors.length; // 12 segments to the circle
                for (var i = 0; i < colors.length; i++) {

                    var currentColor = getColorAtAngle(angle + i * segmentAngle); //calculating current color from angle
                    c.fill(currentColor);
                    c.stroke(currentColor);
                    // Calculate arc coordinates
                    var startAngle = i * segmentAngle - c.HALF_PI;
                    var endAngle = (i + 1) * segmentAngle - c.HALF_PI;
                    c.arc(0, 0, size, size, startAngle, endAngle, c.PIE); // drawing the arc with start/end angles
                }

                angle += 0.04; //spinny
            };

            function getColorAtAngle(angle) {

                var index = c.floor(c.map(angle % c.TWO_PI, 0, c.TWO_PI, 0, colors.length)); // find the index of the color from angle

                var fraction = (angle % (c.TWO_PI / colors.length)) / (c.TWO_PI / colors.length); //  the section between the current color and the next color
                // Interpolate between the current color and the next color
                return c.lerpColor(c.color(colors[index]), c.color(colors[(index + 1) % colors.length]), fraction); // lerp between the current color and the next color
            }
        };

        var myp5 = new p5(sketch); // init sketch so it's visible
    </script>

</body>

</html>
