<!DOCTYPE html>
<html>

<head>
    <title>What is Colour?</title>
    <link rel="icon" href="Images/icon-06.png" type="image/x-icon">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js" integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body style="background-color: grey;">

    <div class="topnav">
        <a href="index.html">What is Noise?</a>
        <a class="active" href="what_is_colour.html">What is Colour?</a>
        <a href="how_they_connect.html">The Connection</a>
        <a href="pick_your_colour.html">Pick Your Colour</a>
        <a href="white_noise.html">White</a>
        <a href="pink_noise.html">Pink</a>
        <a href="blue_noise.html">Blue</a>
        <a href="brown_noise.html">Brown</a>
        <a href="violet_noise.html">Violet</a>
    </div>

    <!-- First Information on Colour Section -->
    <div class="colourcontainer1">
        <h1 class="backgroundtext">What is Colour?</h1>
        <p class="whatiscolourtext">
            Colour is what is visible when light rays bounce off of an object.
            One way to showcase every perceived colour is through a prism.
        </p>
        <div id="prismContainer" class="prismContainer"></div>
        <div id="colourbackground"></div>
        <p class="whatiscolourtext">
            Prisms allow us to visually see how light can be reflected off objects.
        </p>
        <a href="#What is Colour Again?">
            <div class="scroll-down-colour"></div>
        </a>
    </div>

    <!-- Second Information on Colour Screen -->
    <a id="What is Colour Again?"></a>
    <div class="colourcontainer2">
        <h1 class="backgroundtext2">The Colour Wheel</h1>
        <div id="wheelContainer" class="wheelContainer"></div>
        <p class="whatiscolourtext2">
            Lorem, ipsum dolor sit amet consectetur adipisicing elit. Laboriosam illo doloremque ad, maxime itaque quo ea ducimus.
        </p>
    </div>
    <a href="#third">
        <div class="scroll-down-third"></div>
    </a>

    <!-- Third Information on Colour Screen -->
    <a id="third"></a>
    <div class="colourcontainer3">
        <h1 class="backgroundtext3">Third Time Asking?</h1>
        <p class="whatiscolourtext3">
            Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eos unde cum veritatis.
        </p>
        <img class="placebearBrown" src="Images/Colour.1">
    </div>

    <div class="whatIsColourP5Container"></div>

    <script>
    let angle = 0;
let lightBeamLength = 250; // Initial length of the light beam
let lightIntersecting = false; // Flag to indicate if the light beam intersects with the triangle
let spectrumLength = 50; // Initial length of the spectrum lines

function setup() {
  createCanvas(600, 600);
  background(0);
  frameRate(120);
}

function draw() {
  background(0); // Clear the background on each frame
  lightBeam();
  spectrum();
  innerPrism();
  prism();
}

function lightBeam() {
  let endX = mouseX;
  let endY = mouseY;
  
  // Calculate intersection point with the triangle
  let intersection = getLightBeamTriangleIntersection(0, 350, endX, endY);
  if (intersection) {
    endX = intersection.x;
    endY = intersection.y;
    lightIntersecting = true; // Set flag to true if light intersects with triangle
  } else {
    lightIntersecting = false; // Set flag to false if light does not intersect with triangle
  }
  
  // Draw dotted line for the light beam
  stroke(255);
  strokeWeight(2);
  let dottedSpacing = 8; // Adjust the spacing between dots
  for (let i = 0; i < lightBeamLength; i += dottedSpacing * 2) {
    let x1 = lerp(0, endX, i / lightBeamLength);
    let y1 = lerp(350, endY, i / lightBeamLength);
    let x2 = lerp(0, endX, (i + dottedSpacing) / lightBeamLength);
    let y2 = lerp(350, endY, (i + dottedSpacing) / lightBeamLength);
    line(x1, y1, x2, y2);
  }
}

function prism() {
  noFill();
  strokeWeight(6);
  stroke(255);
  triangle(300, 200, 175, 400, 425, 400);
  noFill();
  strokeWeight(4);
  stroke(255, 150); // Adjusted stroke color for better visibility
  triangle(300, 203, 178, 397, 422, 397);
}

function innerPrism() {
  let x1 = 255, y1 = 280, x2 = 345, y2 = 266;
  let n = 0;
  while (n < 11) {
    stroke(255, 20); // Adjusted stroke color for better visibility
    strokeWeight(0.5); // Adjusted stroke weight for better visibility
    line(x1, y1, x2, y2);
    x2 += 1.3;
    y2 += 3.45;
    n++;
  }
}

function spectrum() {
  let lightX = mouseX;
  let lightY = mouseY;
  
  if (lightIntersecting) {
    let lightAngle = atan2(lightY - 350, lightX); // Calculate the angle of the light beam
    
    let x1 = 348, y1 = 270; // Start point of the spectrum line
    let x2 = x1 + spectrumLength * cos(lightAngle); // End point of the spectrum line
    let y2 = y1 + spectrumLength * sin(lightAngle); // End point of the spectrum line
    
    // Draw the spectrum line
    let colors = [
      [255, 34, 0],
      [255, 119, 0],
      [255, 191, 0],
      [255, 238, 0],
      [221, 255, 0],
      [80, 255, 0],
      [0, 255, 0],
      [0, 170, 255],
      [0, 34, 255],
      [136, 50, 255],
      [230, 75, 175]
    ];
    
    for (let n = 0; n < 11; n++) {
      let [a, b, c] = colors[n];
      stroke(a, b, c, 250); // Adjusted stroke color and alpha for better visibility
      strokeWeight(5); // Adjusted stroke weight for better visibility
      line(x1, y1, x2, y2);
      x1 += 2.2;
      y1 += 3;
      spectrumLength += 2; // Increase the spectrum length for the next iteration
    }
  }
}

function getLightBeamTriangleIntersection(x1, y1, x2, y2) {
  // Triangle vertices
  let v1 = createVector(300, 200);
  let v2 = createVector(175, 400);
  let v3 = createVector(425, 400);

  // Check intersection with each triangle edge
  let intersection1 = getLineIntersection(x1, y1, x2, y2, v1.x, v1.y, v2.x, v2.y);
  let intersection2 = getLineIntersection(x1, y1, x2, y2, v2.x, v2.y, v3.x, v3.y);
  let intersection3 = getLineIntersection(x1, y1, x2, y2, v3.x, v3.y, v1.x, v1.y);

  // Return the nearest intersection point
  let nearestIntersection = null;
  if (intersection1 && (!nearestIntersection || dist(x1, y1, intersection1.x, intersection1.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
    nearestIntersection = intersection1;
  }
  if (intersection2 && (!nearestIntersection || dist(x1, y1, intersection2.x, intersection2.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
    nearestIntersection = intersection2;
  }
  if (intersection3 && (!nearestIntersection || dist(x1, y1, intersection3.x, intersection3.y) < dist(x1, y1, nearestIntersection.x, nearestIntersection.y))) {
    nearestIntersection = intersection3;
  }

  return nearestIntersection;
}

function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
  // Calculate the direction vectors of the lines
  let uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  let uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

  // If the intersection point is within both line segments, return the coordinates
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
    let intersectionX = x1 + (uA * (x2 - x1));
    let intersectionY = y1 + (uA * (y2 - y1));
    return createVector(intersectionX, intersectionY);
  } else {
    return null;
  }
}



    </script>

    <script>
        // COLOUR WHEEL 
        var sketch = function (c) {
            // defining colours
            const red = "#FE2712";
            const redOrange = "#FC600A";
            const orange = "#FB9902";
            const yellowOrange = "#FCCC1A";
            const yellow = "#FEFE33";
            const yellowGreen = "#B2D732";
            const green = "#66B032";
            const blueGreen = "#347C98";
            const blue = "#0247FE";
            const bluePurple = "#4424D6";
            const purple = "#8601AF";
            const redPurple = "#C21460";

            const size = 400; // size of wheel (tbc)
            const colors = [red, redOrange, orange, yellowOrange, yellow, yellowGreen, green, blueGreen, blue, bluePurple, purple, redPurple]; // so i don't have to ref each individually

            let angle = 0; // starting off to spin it

            c.setup = function () {
                let wheel = c.createCanvas(920, 456);
                wheel.parent('wheelContainer');
            };

            c.draw = function () {
                c.translate(c.width / 2, c.height / 2); // center of page
                var segmentAngle = c.TWO_PI / colors.length; // 12 segments to the circle
                for (var i = 0; i < colors.length; i++) {

                    var currentColor = getColorAtAngle(angle + i * segmentAngle); //calculating current color from angle
                    c.fill(currentColor);
                    c.stroke(currentColor);
                    // Calculate arc coordinates
                    var startAngle = i * segmentAngle - c.HALF_PI;
                    var endAngle = (i + 1) * segmentAngle - c.HALF_PI;
                    c.arc(0, 0, size, size, startAngle, endAngle, c.PIE); // drawing the arc with start/end angles
                }

                angle += 0.04; //spinny
            };

            function getColorAtAngle(angle) {

                var index = c.floor(c.map(angle % c.TWO_PI, 0, c.TWO_PI, 0, colors.length)); // find the index of the color from angle

                var fraction = (angle % (c.TWO_PI / colors.length)) / (c.TWO_PI / colors.length); //  the section between the current color and the next color
                // Interpolate between the current color and the next color
                return c.lerpColor(c.color(colors[index]), c.color(colors[(index + 1) % colors.length]), fraction); // lerp between the current color and the next color
            }
        };

        var myp5 = new p5(sketch); // init sketch so it's visible
    </script>

</body>

</html>
